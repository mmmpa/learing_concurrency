# 1 章

具体的なアルゴリズムなどではなく、目的・考え方・向き合い方などを解説する触りの章だった。

## 併行化にはオーバーヘッドが必ずある

逐次実行時には存在しなかった併行化の処理が入るためオーバーヘッドがある。取り扱いの難しさから実装面でのオーバーヘッドもある。

したがって、並行化が可能か不可能かということは判断の主因としてはならない。また、処理時間の 7% しか占めてない部分ではなく、93% を占めているような部分をターゲットとする必要がある。

そして並行化してその結果高速化できるかが問題となる。

## 並行化のための分割

- 処理対象のデータを分割し、各プロセスで同じ処理をさせる
- タスクを分割し、各プロセスでちがう処理をさせる

## プロセスへの静的・動的割当

各プロセスへ割りあてる内容を最初に全て決定するのが静的割当である。一方、進捗に従って割り当てていくのが動的割当である。

処理時間がほぼ同じであったり最初から推測可能な場合は静的割当を行う。処理時間が大きく異なる場合や、不明な場合は動的割当のほうが効率的なことがある。

## 共有リソースの取りあつかいが大きな要素となる

並行化されたプロセスが参照・更新するリソースについて保証する必要がある。特に同時更新時の結果を保証する必要がある。

## 共有メモリプログラミング・分散メモリプログラミング

共有メモリプログラミングではおなじメモリをプロセス間で参照するので、共有リソースの参照・更新が容易である。

分散メモリプログラミングではプロセス間のメモリ空間が独立しているため、共有リソースの参照・更新に送受信が必要になる。

### Go 言語で考えた

Effective Go 曰く

>メモリを共有することで通信しようとしないこと。代わりに通信することでメモリを共有すること。

`goroutine` での共有リソースアクセスは `channel` を用いることが推奨されている。

`mutex` による共有が共有メモリプログラミングだとすると、`channel` での共有は分散メモリプログラミングだと考えるとしっくりくるのではないだろうか。


### Producer-Consumer アルゴリズム

共有メモリプログラミングでの分配アルゴリズムの一つ。

`Producer` がタスクをカプセル化し `queue` に詰め込む。`Consumer` は `queue` のタスクが全て消化されるまでタスクを取りだし、処理を続ける。`queue` へのアクセスは排他制御が必要である。 

(`goroutine` の用法でよくみる。`queue`, `Consumer` をそれぞれ `goroutine` とし `channel` で繋ぐ)
